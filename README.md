### TON

В файле tests/main.spec.tc содержатся первые попытки эмулировать все необходимые функции для управления и прерывания транзакций, просмотра очереди сообщений, изменения порядка очереди, а также для просмотра и записи логов сообщений, обработанных в ходе выполнения конкретной транзакции.

`yarn test`

### TON Debug Console 

Здесь я опишу сценарии того, как будет примерно выглядеть инструмент: 

Запуск интерактивной консоли: 

`tondebug --contract ./contracts/main.fc --initial-state ./states/init_state.json --queue ./messages/queue.json`

`--contract` указываем путь до смарт-контракта (под капотом компилируем его через compile.ts и если буду ошибки при компилировании, не запускаем интерактивную консоль)

`--initial-state` это опциональная команда для того, чтобы задать начальное состоения контракта (необходимо под капотом перед запуском консоли интерактивной провалидировать, что состояние задано через code/balance/data)

`--queue` здесь пользователь передает список входящих сообщений, если что их можно будет добавлять и по ходу в интерактивной консоли  (подумать над форматом сообщений)

`--help` стандартная команда с описанием всех возможностей

После удачной компиляции конракта запускаем интерактивную консоль откладчика: 

`tondebug> help` такая же команда с инструкцией 

`tondebug> run next` допустим, у нас в queue.json очередь сообщений, которую мы пронумеровали от 1 до N. При выполнении `run next` откладчик возьмет первое сообщение из очереди и выполнит его, после этого откладчик останавливается и не переходит к исполнению другого. В логи можем выводить подробнее что за сообщение было обработано, какой статус исполнения, ...

`tondebug> continue` исполняем все оставшиеся сообщения без прерывания

`tondebug> show state` показываем состояние TVM на текущий момент до/после обработки сообщений (balance, extracurrency, last transaction, state)

`tondebug> show transactions` выводим список исполненных транзакций

`tondebug> load state PATH` позволяем задать состояние TVM (сode/balance/data) (подумать, как будем валидировать)

`tondebug> save state PATH` пользователь указывать путь, куда сохранить текущий стейт TVM (возможно их можно сохранять по какому-то локальному пути после каждого исполнения и тогда в diff пользователь только укажет название файлов)

`tondebug> diff state PATH1 PATH2` например, пользователь сохранил состояние до исполнения сообщения и после, тогда чтобы сравнить их можно вызвать такую команду

`tondebug> queue list` просмотр оставшихся сообщений

`tondebug> run message N` если пользователь захочет обработать конкретное сообщение, то он может указать его номер из листа оставшихся сообщений. Так же в логи выводит что за сообщение обработали, какой статус исполнения, ...

`tondebug> set queue --order {reverse/random}` можем позволить пользователю выбрать способ того, как перемешать очередь. В лог выводим порядок сообщений, который получился

`tondebug> add messages PATH` пользователь указывает путь к JSON файлу с сообщениями, которые он хочет добавить

`tondebug> delete message N` удаляем N сообщение из очереди ожидающих сообщений

`tondebug> script load PATH` можем позволить пользователю самому задать скрипт с алгоритмом по перемешиванию очереди ожидающих сообщений (только надо будет тогда задать формат скрипта)

`tondebug> script run` запускаем скрипт на текущей очереди ожидающих сообщений и в лог выводим, какой порядок получился

`tondebug> run get-method --name NAME` пользователб может вызвать метод конракта, чтобы посмотреть, что он вернет после или до исполнения сообщений

`tondebug> show message log` выводим лог порядка выполненных сообщений (возможно их можно сохранять по какому-то локальному пути)

`tondebug> exit` выходим из интерактивной консоли
